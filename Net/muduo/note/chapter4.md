# chapter4 C++多线程

## 线程创建与销毁
- 以相同的方式创建线程
- 进入main之前不应该创建线程，可能会影响全局变量的创建
- 创建应在初始化阶段完成，执行时基本不创建
- 使用一个Manager类管理线程(需要考虑野生线程)
- 退出一个多线程程序是困难的，因为会涉及到其他正在进行的线程的安全退出
- 编程服务器程序，可以让服务器进入拒绝服务的状态。然后直接杀死

## __thread
只能修饰POD不能修饰class
只能修饰global和static
初始化为必须为编译期常量
作用:每个线程独占一份，互不干扰

## IO
一个文件由一个线程进行读写
一个线程可以操作多个文件，但不能使用其他线程操作的文件
特例:
必要的时候多个线程操作同一文件读写(pread pwrite)
由于UDP协议本身，适当的时候(消息之前独立)多个线程读写UDP

## fork
多线程和fork()协作性差，一个多线程fork后，子进程只剩下一个线程，其他线程可能持有锁，导致子进程使用不了线程安全的函数(除非可重入)
最安全的方法就是fork后直接exec

## signal
多线程下不要使用signal
- 不要作为ipc的手段
- 不要基于signal实现定时
- 不主动处理异常，使用默认
- 如果实在需要用signal处理，把异步信号转为同步的文件描述符事件。可以在handler里使用特定的pipe写一个字节，从主程序读,纳入处理框架(现代Linux使用signalfd函数，将信号转为文件描述符，避免使用handler)

<!-- 暂且停滞 -->

