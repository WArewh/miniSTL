#include <iostream>
using namespace std;

/*
    特种成员函数是指在创建类时会自动生成的成员函数：默认构造函数、析构函数、复制操作、移动操作
    特种成员函数属性为public inline
    特种成员函数的默认生成，一句话概括为只在最需要的地方生成，但不能产生错误
    比如：
        - 用户写了一个带参数的构造函数，这个时候生成一个默认构造函数就是不必要的
          因为编译器认为已经有了一个构造函数，不需要自己创建一个
        - 用户写了一个复制构造函数，这个时候移动操作就是不必要的
          因为可以通过复制来生成对象，移动不是必要的
        - 用户写了一个移动构造函数，这个时候生产移动赋值函数就是有可能出错的
          编译器认为普通的移动操作是不对的，因此不产生移动赋值函数
*/

/*
    类中不包含用户声明的构造函数（一切构造）才会自动生成一个默认构造函数
    原因在于如果用户声明了一个构造函数，那么编译器认为自动生成的默认的构造函数会有问题
*/
class A1
{
};

class A2
{
public:
    A2(int a) {}
};

void f1()
{
    A1 a1;
    // A2 a2;
}

// 析构函数默认noexcept(C++11之后) 只有基类析构为虚，派生析构才为虚
// ...

/*
    类中复制构造和复制赋值运算符相互独立，移动构造和移动复制不相互独立
    复制操作独立是因为兼容C++11之前的版本，因此编译器不会报错(不推荐)
    移动不独立，是因为用户声明了移动操作，则编译器认为普通的移动操作不适用

    有复制就没有移动　有移动就没有复制
    可以通过复制(移动)来生成对象，移动(复制)不是必要的
*/
class B1
{
public:
    B1() {}
    B1(const B1& b) { cout << "copy\n"; }
    // B1 operator=(const B1& b) { cout << "copy operator\n"; }
};

class B2
{
public:
    B2() {}
    B2(B2&& b) { cout << "move\n"; }
    // B2& operator=(B2&& b) { cout << "move operator\n"; }
};

void f2()
{
    B1 b1;
    B1 b2{b1};
    B1 b3 = b1;
    // B1 b4{B2()};
    B1 b5;
    // b5 = B2();


    B2 b6;
    // b6 = B2();
    B2 b7{B2()};
    // B2 b8(b6);
    B2 b8;
    // b8 = b6;
}

/*
    用户定义了析构函数，复制和移动就需要定义
    因为定义了析构函数，那么就暗示了某种资源的管理，普通的移动和复制就可能有错误
    比如：
        shared_ptr的计数器
*/

class C
{
public:
    ~C() {}
};


void f3()
{
    // 没有报错是因为兼容C++以前的版本

    C c1;
    C c2(c1);
    C c3;
    c3 = c1;
}

int main()
{
    f2();
}