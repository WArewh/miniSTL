# 从汇编层面看引用和指针
```
//使用的指令为g++ -S
int a = 10;
// movl	$10, -12(%rbp)  a的地址为R[%rbp]-12的内容
int &b = a;
// leaq	-12(%rbp), %rax rax为a的地址
// movq	%rax, -8(%rbp)  b的地址为R[%rbp]-8的内容,存储a的地址
b = 20;
// movq	-8(%rbp), %rax  rax为b的地址
// movl	$20, (%rax)     M[rax]即a和b的地址=20
```
可以看出引用和指针在汇编层面上没有什么不同，引用的实现就是指针。因此int&b=20编译报错，是因为20是立即数不能取地址。那么const int&=20为什么可以通过编译且可以正常运行呢?
```
const int &a = 20;
// movl	$20, %eax
// movl	%eax, -12(%rbp)
// leaq	-12(%rbp), %rax
// movq	%rax, -8(%rbp)
```
可以发现const int&之所以可以指向常量是因为编译器自动生成了一个临时变量让20这个数有地址可取，但不能对其进行修改。再来看看右值引用。
```
int &&a = 20;
// movl	$20, %eax
// movl	%eax, -12(%rbp)
// leaq	-12(%rbp), %rax
// movq	%rax, -8(%rbp)
```
可以知道常量引用和右值引用在汇编层面上也是相同的，而且右值引用可以进行写操作

# 右值引用的好处
右值引用可以得到临时对象并且可以对临时对象进行修改，可以想到临时对象的创建往往和拷贝构造有关
先来看看拷贝构造函数发生的时机  
- 用创建好的对象初始化另一个对象  
- 值传递给函数参数  
- 局部对象作为返回值(一般会优化)  
可以发现有些时候其实可以不用拷贝构造,比如
```
vector<string>vec;
// 传递的是const char*,会通过string(const char*)的构造函数构造出string
vec.push_back("aaa");
```
没有右值引用会使用拷贝构造函数，由于字符串可能很长会导致效率低下，如果使用右值引用只需要将string的指针给到需要的对象，大大提高了对象的使用效率