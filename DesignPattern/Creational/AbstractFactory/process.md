# 背景
小W加入了一个游戏开发团队，它们正要开发一款迷宫类游戏(roguelike)，其中你负责开发迷宫布局这一部分

# stage1
团队经过一段时间讨论，你得到如下要求：
1. 一个迷宫有不同尺寸
2. 一个迷宫是由多个房间组成
3. 房间有四个方向，每个方向可以是墙、门(打开和关闭)
4. 房间有多种类型，比如普通房、精英房、boss房等
5. 创建一个简单布局来进行测试

# solution1
1. 创建一个Maze类来创建迷宫，它由一个二维Room*类的数组构成，由于有不同尺寸的迷宫因此也需要一个Maze基类
2. 由于有多种房间，因此可以抽象出一个Room的基类
3. 每个方向上有多种选择，因此也可抽象出一个RoomEdge的基类
4. 创建枚举类Direction标识方向
5. 创建MazeTester类，使用createTestMaze方法进行布局并测试
具体代码见stage1.h

# stage2
需求完成不久，开始了第二次讨论，要求如下
1. 添加木墙、石墙、铁墙
2. 添加木门、石门、铁门
3. 小迷宫的配置是木门木墙普通房、中迷宫的配置是石门石墙精英房、大迷宫的配置是铁门铁墙boss房
4. 将添加的东西进行测试

# analyse
对于要求3可以对原函数进行修改，但是每次迭代都需要修改原来的代码，而且需要增加更多的类，将使得我们的修改急剧增加。原因在于我们对布局使用了硬编码，将代码写死了，只能通过修改原来的代码。比如，需求3将迷宫分为三个系列，每个系列都有固定的对象组成，这个时候就需要设计模式中的抽象工厂

# solution2
1. 在Wall和Door的基础上继续派生新类
2. 使用抽象工厂方法
具体代码见stage2.h、AbstractFactory.h

# stage3
经过重构后，开始第三次迭代
1. 添加巨大迷宫
2. 巨大迷宫有水晶门、水晶墙、水晶房

# solution3
直接派生相关类，添加一个抽象工厂即可，可以发现不用修改原有代码
具体代码见stage3.h

# stage4
经过了三次迭代，马上新的一轮讨论结果出炉，需求如下
1. 在迷宫里添加装饰物
2. 不同等级的迷宫装饰物不同

# analyse
抽象工厂方法在添加新系列上很简单，但是添加增加新的相关物品很麻烦


# solution4
1. 需要一个新基类ornament来派生其他类
2. 需要在原有的代码下面进行少量的修改
具体代码见stage4.h
