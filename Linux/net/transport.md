# TCP/UDP

## UDP
无连接不可靠，没有流量控制堵塞控制，尽最大可能交付，面向报文，支持一对一、一对多、多对多，也不差分也不合并只添加首部

UDP不存在粘包和拆包，因为其首部有长度信息


## TCP
面向连接可靠，有流量控制堵塞控制，全双工，一对一，把报文看成字节流，差分成数据块

### 三次握手
客户端发送连接请求，携带SYN标志
服务端应答，是否收到客户端请求同时向客户端发起请求，携带ACK，SYN
客户端应答，是否收到服务端请求同时携带ACK，SYN

目的：
第一次握手：服务端知道客户端发送和接收没问题
第二次握手：客户端知道服务端发送和接收、客户端的发送和接受
第三次握手：服务端和客户端都知道自己的发送和接收没问题
例子:客户端第一次连接请求在网络中堵塞，于是客户端超时重传，连接成功并在传输数据完成后释放连接，这个时候连接请求到达了服务端，如果使用两次握手会导致服务端以为客户端重新发送了请求导致资源浪费。

### 发送数据

滑动窗口最左面是未被确认的第一个数据，如果确认则往前滑动

### 堵塞控制

慢开始和拥塞避免

设发送报文段为X,门限值为T

慢开始：令X=1，如果接收成功则下次发送X*=2，这样在一段时间后增速会很快，因此设置一个门限((拥塞避免))，大于等于门限则将X+=1，如果超时，T=X/2，在重新执行慢开始

快重传和快恢复

当丢失个别报文段时，发送方收到前一个包的三个重复确认，使用快重传发送这个包，同时，启动快恢复，将T=X/2,X=T,进入拥塞避免

![](./Linux/images/congestion control.jpg)


### 粘包和拆包
发送的数据大小大于缓冲区剩余空间会发生拆包
发送的数据大小大于最大报文长度会发生拆包
发送的数据大小小于缓冲区剩余空间将多个包合并发生粘包
应用层没有及时读取数据导致粘包

解决方法：
消息定长
设置消息边界
添加长度信息字段


### 四次握手
客户端发送关闭请求，携带FIN标志
服务端应答关闭请求，携带ACK应答(完成这一步处于半关闭状态)
服务端发送关闭请求，携带FIN标志
客户端应答关闭请求，携带ACK应答

第四次握手时客户端会等待2个最长报文段寿命(MSL)的时间
保证ACK报文到达服务端

半关闭：一端告诉另一端已经完成了数据的发送，只能接受数据，直到另一端也发送关闭请求。
当服务端得到FIN报文可能还没有发送完所有报文，因此只能告诉客户端我收到了，直到所有报文发送完才能发送FIN

